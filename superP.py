#!/bin/env python
from Bio.PDB import *
import numpy as np
import argparse
import sys
import os.path

def superpose(chain1,res1,chain2,res2,structure):
    '''Superposes the atoms in chain2 res2 over those in chain1 res1
    Returns a tuple containing the rotation matrix and translation vector
    needed to apply to chain2 res2'''
    # Perform superposition
    sup = Superimposer()
    fixed  = [atom for atom in res1]
    moving = [atom for atom in res2]
    
    # Get rid of hydrogens which may or may not exist in either structure and keep only
    # the phosphate backbone
    extractPhosphate(fixed)
    extractPhosphate(moving)
    
    # There should be four atoms in each atom set, if not, skip.
    if len(fixed) != 4 or len(moving) != 4: return -1
    # Calculate the rotation matrix and translation vector
    try:
        sup.set_atoms(fixed,moving)
    except Exception as e:
        # Is it due to size mismatch?
        print ("Error superimposing PX.")
        print ('fixed atoms:',len(fixed),fixed)
        print ('moving atoms:',len(moving),moving)
        raise e
    # Return rotation matrix and translation vector
    return (sup.rotran,sup.rms)
    
def writeCSV(matrices,outfile):
    '''Takes our rotation matrices and translation vectors and outputs them as
     a csv file containing the chains,residues, and unrolled matrices and
      vectors in the following format:
    chain1,res1,chain2,res2,m11,m12,m13,m21,m22,m23,m31,m32,m33,v1,v2,v3,rms
    '''
    out = open(outfile,"w+")
    out.write("chain1,res1,chain2,res2,m11,m12,m13,m21,m22,m23,m31,m32,m33,v1,v2,v3,rms\n")
    for (chain1,res1,chain2,res2,((rot,tran),rms)) in matrices:
        out.write("%s,%i,%s,%i,"%(chain1,res1,chain2,res2))
        out.write("%f,%f,%f,"%(rot[0][0],rot[0][1],rot[0][2]))
        out.write("%f,%f,%f,"%(rot[1][0],rot[1][1],rot[1][2]))
        out.write("%f,%f,%f,"%(rot[2][0],rot[2][1],rot[2][2]))
        out.write("%f,%f,%f,%f\n"%(tran[0],tran[1],tran[2],rms))
    out.close()

def extractPhosphate(atoms):
    '''Given an input set of atoms, removes non-phosphate atoms'''
    # DNA backbone
    phosphate = ['P','OP1','OP2','O5\'']
    i = 0
    size = len(atoms)
    while i < size:
        if atoms[i].get_id() not in phosphate:
            atoms.pop(i)
            size -= 1
        else:
            i += 1
    # Make sure they're all in the right order
    atoms = sorted(atoms,key=lambda x: phosphate.index(x.get_id()))
    return atoms
    
def readMatrix(matfile):
    '''Read the matrix files generated by writeCSV'''
    min = open(matfile)
    output = [line.split(',') for line in min]
    min.close()
    output.pop(0)
    return output
    
    
def prune(mat,done):
    '''Take off where we left off.  eliminate any entries in mat that have 
    already been done'''
    lines = []
    with open("%s.csv"%(done)) as fin:
        lines = [line.split(',') for line in fin]
    mat = [entry for entry in mat if entry not in lines]
    with open("%s_r.csv"%(done)) as fin:
        lines = [line.split(',') for line in fin]
    mat = [entry for entry in mat if entry not in lines]
    return mat
    

def removeSimilar(pdb,mat1,mat2,cutoff,out,done=None):
    '''Given two superposition matrices, remove any superposition from mat1 where
    mat2 contains a superposition that results in an RMSD within cutoff'''
    # Setup MPI
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    size = comm.Get_size()
    # Read the matrices
    mat1 = readMatrix(mat1)
    mat2 = readMatrix(mat2)
    # Done is used to save our progress if we stopped for some reason.
    # Let's look at all the ones we've already done
    if done is not None and os.path.isfile("%s.csv"%(done)):
        mat1 = prune(mat1,done)
        print("Pruning matrix");sys.stdout.flush()
    # Open the output csv files
    rout = open("%s_r_%i.csv"%(out,rank),'a')
    fout = open("%s_%i.csv"%(out,rank),'a')
    # initialize output list
    output = []
    # for every entry in mat1
    for i in range(rank,len(mat1),size):
    # for entry1 in mat1:
        entry1 = mat1[i]
        # for every entry in mat2
        failed = False
        for entry2 in mat2:
            print(' ',rank,entry1[0:4],entry2[0:4],'        ',end='\r');sys.stdout.flush()
            # load pdb
            parser = PDBParser()
            struc = parser.get_structure(pdb,pdb)
            # extract mat1 atoms
            atoms1 = extractPhosphate([atom for atom in struc[0][entry1[0]][int(entry1[1])]])
            # perform mat2 sup on mat1 atoms
            rot = [float(x) for x in entry2[4:13]]
            rot = np.reshape(np.array(rot),(3,3))
            tran = [float(x) for x in entry2[13:16]]
            tran = np.array(tran)
            # if dist(mat1 a,b) < cutoff, remove from output
            atoms1P = [atom for atom in atoms1 if atom.get_id()=='P']
            atoms2 =[atom for atom in struc[0][entry1[2]][int(entry1[3])] if atom.get_id()=='P']
            atoms1P[0].transform(rot,tran)
            dist = atoms2[0] - atoms1P[0]
            if dist < cutoff:
                failed = True
                print("\nRemoving",entry1[0:4])
                rout.write(','.join(entry1))
                rout.flush()
                break
        # If an entry is not eliminated, add it it to the output
        if not failed:
            fout.write(','.join(entry1))
            fout.flush()
    fout.close()
    rout.close()
    
def main():
    parser = argparse.ArgumentParser()
    # input pdb
    parser.add_argument('-f',dest='pdb',help='DNA PDB file to be superposed')
    # output csv file
    parser.add_argument('-o',dest='outfile',help='CSV file to save output to')
    parser.add_argument('--sub',action='store_true')
    parser.add_argument('-m1')
    parser.add_argument('-m2')
    args = parser.parse_args()
    pdb = args.pdb
    outfile = args.outfile
    
    if(args.sub):
        removeSimilar(pdb,args.m1,args.m2,3.0,outfile,outfile)
    else:
        # Read in pdb file
        pdbParser = PDBParser()
        structure = pdbParser.get_structure('structure',pdb)
        # Initialize output list
        output = []
        # Iterating over every chain and residue
        for chain1 in structure[0]:
            for res1 in chain1:
                for chain2 in structure[0]:
                    for res2 in chain2:
                        print(chain1.get_id(),res1.get_id()[1],chain2.get_id(),res2.get_id()[1],end="\r")
                        # Superpose their phosphates and add them to the list
                        sup = superpose(chain1,res1,chain2,res2,structure)
                        if sup != -1:
                            output.append((chain1.get_id(),res1.get_id()[1],chain2.get_id(),res2.get_id()[1],sup))
        # Write out the csv file
        writeCSV(output,outfile)
    
if __name__ == "__main__": main()